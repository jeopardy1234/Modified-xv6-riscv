# XV6 RISCV

## SCHEDULING ALGORITHMS:

- ### FCFS:

  - First, disable the preemptive scheduling for FCFS scheduling. For doing this, go to `trap.c`. Under `usertrap()` and `kerneltrap()` place the `yield()` section of code under `#ifdef` as follows:

    ```c
    #ifdef FCFS
    	//relevant code
    	yield()
    #endif
    ```

  - Go to `proc.h` , and under `struct proc` , define a new variable `start time`.
  - Go to `proc.c`. Under `allocproc()`, initialize this newly created variable as `p->create_time = ticks`.
  - Next, traverse the process table, and find a process with status `RUNNABLE`, which has the shortest start time.
  - Schedule this process, while acquiring and releasing the locks appropriately.

- ### PBS:

  - Under `struct proc` in `proc.h`, define six new variable `time_stopped` and `time_stopped_temp`, `times_chosen` , `static_priority` , `dynamic_priority` and `niceness`.
  - Whenever the process goes to sleep, it enters the `sleep()` function in `proc.c`. Over here, set `time_stopped_temp = ticks`. Now go to `wakeup()`. From here, we can find the time for which the process was sleeping. So, just do `time_stopped += (ticks - time_stopped_temp)`. 
  - The `waitx()` function already checks for the runtime under the variable `rtime`, so we need not implement is separately. Using `p->rtime` and `p->time_stopped` we can calculate niceness.
  - Now just scan the process table, and schedule the appropriate process according to the priority order <dynamic priority, numer of times it was scheduled before, start time>. We can keep updating `dynamic_priority` , `niceness` and `times_chosen` here itself.
  - `setpriority()` can be easily implemented by making a stub in user space, and changing the appropriate files as we did in spec 1.

  
